# 服务端正式部署优化方案

> 目标服务器：与 MySQL 同机部署（122.51.106.231），消除网络延迟
> 技术栈：PHP 8.1 + ThinkPHP 5 + MySQL + Nginx + Redis

---

## 一、同机部署的收益

将 PHP 应用与 MySQL 部署在同一台服务器后：

| 对比项 | 当前（跨机） | 同机部署 |
|--------|-------------|---------|
| PHP ↔ MySQL 延迟 | 1-10ms / 次查询 | < 0.1ms（Unix Socket） |
| 7 次查询的网络开销 | 7-70ms | < 0.7ms |
| 连接建立耗时 | 3-15ms（TCP三次握手） | < 0.5ms |
| 数据传输 | 受带宽限制 | 内存级速度 |

**结论**：同机部署后，数据库网络延迟问题基本消除。但以下问题仍然存在，必须优化：

- `php -S` 单线程 → 并发为 0（必须换 Nginx + PHP-FPM）
- 无缓存 → 每次请求都查库（需要 Redis）
- 查询过多 → 单页面 15+ 次查询（需要合并优化）
- 缺少索引 → status/factory_id 等高频字段无复合索引

---

## 二、推荐服务器配置

### 最低配置（50-100 并发用户）

| 资源 | 配置 |
|------|------|
| CPU | 2 核 |
| 内存 | 4 GB |
| 磁盘 | 50 GB SSD |
| PHP-FPM | 20 个 worker |
| MySQL | 已有 |
| Redis | 128 MB 内存 |

### 推荐配置（200-500 并发用户）

| 资源 | 配置 |
|------|------|
| CPU | 4 核 |
| 内存 | 8 GB |
| 磁盘 | 100 GB SSD |
| PHP-FPM | 50 个 worker |
| MySQL | 已有 |
| Redis | 256 MB 内存 |

---

## 三、部署架构图

```
客户端（UniApp / 浏览器）
        │
        ▼
   Nginx（:80/:443）
   ├── 静态资源直接返回（/assets/, /uploads/）
   └── PHP 请求 → PHP-FPM（Unix Socket）
                      │
                ┌─────┴─────┐
                ▼            ▼
            MySQL         Redis
        (Unix Socket)   (127.0.0.1:6379)
```

---

## 四、分步骤优化实施

### 第 1 步：安装基础环境

```bash
# CentOS / AlmaLinux
yum install -y nginx php81-fpm php81-mysqlnd php81-redis php81-bcmath php81-json redis

# Ubuntu / Debian
apt install -y nginx php8.1-fpm php8.1-mysql php8.1-redis php8.1-bcmath redis-server
```

### 第 2 步：Nginx 配置

创建 `/etc/nginx/conf.d/xiluxc.conf`：

```nginx
server {
    listen 80;
    server_name your-domain.com;  # 替换为实际域名或IP
    root /var/www/xiluxc/public;
    index index.php index.html;

    charset utf-8;
    client_max_body_size 20m;

    # 静态资源缓存
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff2?|ttf|eot)$ {
        expires 7d;
        access_log off;
        add_header Cache-Control "public, immutable";
    }

    # 上传文件目录
    location /uploads/ {
        expires 30d;
        access_log off;
    }

    # PHP 路由（ThinkPHP URL 重写）
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        fastcgi_pass unix:/run/php/php8.1-fpm.sock;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;

        # 超时设置
        fastcgi_connect_timeout 10s;
        fastcgi_send_timeout 30s;
        fastcgi_read_timeout 30s;
    }

    # 禁止访问隐藏文件
    location ~ /\. {
        deny all;
    }

    # 禁止访问 application、runtime 等目录
    location ~ ^/(application|runtime|thinkphp|vendor|extend)/ {
        deny all;
    }
}
```

### 第 3 步：PHP-FPM 配置

编辑 `/etc/php/8.1/fpm/pool.d/www.conf`：

```ini
[www]
user = www-data
group = www-data

; 使用 Unix Socket（比 TCP 快）
listen = /run/php/php8.1-fpm.sock
listen.owner = www-data
listen.group = www-data

; 进程管理：dynamic 模式
pm = dynamic
pm.max_children = 50          ; 最大 worker 数（4核8G建议50）
pm.start_servers = 10         ; 启动时 worker 数
pm.min_spare_servers = 5      ; 最少空闲 worker
pm.max_spare_servers = 20     ; 最多空闲 worker
pm.max_requests = 1000        ; 每个 worker 处理 1000 个请求后重启（防内存泄漏）

; 慢日志（超过 3 秒的请求记录）
slowlog = /var/log/php-fpm-slow.log
request_slowlog_timeout = 3s
request_terminate_timeout = 30s
```

### 第 4 步：MySQL 使用 Unix Socket 连接

修改项目 `.env` 文件：

```ini
[database]
type     = mysql
hostname = localhost
hostport = 3306
database = andone
username = andone
password = Dp6MT3XnJiA7nP2p
prefix   = fa_
charset  = utf8mb4

; 关键：localhost 时 MySQL 自动使用 Unix Socket
; 如需显式指定：
; socket = /var/run/mysqld/mysqld.sock
```

### 第 5 步：安装并配置 Redis

```bash
# 启动 Redis
systemctl enable redis
systemctl start redis

# 设置密码（可选但建议）
# 编辑 /etc/redis/redis.conf：
# requirepass your_redis_password
# maxmemory 256mb
# maxmemory-policy allkeys-lru
```

修改 ThinkPHP 缓存配置 `application/config.php`：

```php
'cache' => [
    'type'   => 'Redis',
    'host'   => '127.0.0.1',
    'port'   => 6379,
    'password' => '',        // 如设了密码填这里
    'timeout' => 1,
    'prefix'  => 'xiluxc_',
    'expire'  => 3600,       // 默认缓存1小时
],

'session' => [
    'type'       => 'Redis',
    'host'       => '127.0.0.1',
    'port'       => 6379,
    'prefix'     => 'sess_',
    'expire'     => 7200,
],
```

### 第 6 步：数据库索引优化

在 MySQL 中执行：

```sql
-- 订单表：工厂端查询核心索引
ALTER TABLE `fa_jj_order` ADD INDEX `idx_factory_status` (`factory_id`, `status`);
ALTER TABLE `fa_jj_order` ADD INDEX `idx_factory_createtime` (`factory_id`, `createtime`);
ALTER TABLE `fa_jj_order` ADD INDEX `idx_agent_status` (`agent_id`, `status`);

-- 产品表
ALTER TABLE `fa_jj_product` ADD INDEX `idx_factory_status` (`factory_id`, `status`);

-- 保证金表
ALTER TABLE `fa_jj_deposit` ADD INDEX `idx_order_paystatus` (`order_id`, `pay_status`);

-- 合同表
ALTER TABLE `fa_jj_contract` ADD INDEX `idx_order_status` (`order_id`, `status`);

-- 物流表
ALTER TABLE `fa_jj_logistics` ADD INDEX `idx_order_status` (`order_id`, `status`);

-- 佣金表
ALTER TABLE `fa_jj_commission` ADD INDEX `idx_agent_status` (`agent_id`, `status`);

-- 竞标报价表
ALTER TABLE `fa_jj_bid_quote` ADD INDEX `idx_factory_status` (`factory_id`, `status`);
ALTER TABLE `fa_jj_bid_quote` ADD INDEX `idx_bid_factory` (`bid_id`, `factory_id`);

-- 订单日志表
ALTER TABLE `fa_jj_order_log` ADD INDEX `idx_order_id` (`order_id`);

-- 居间人表
ALTER TABLE `fa_jj_agent_profile` ADD INDEX `idx_status_score` (`status`, `credit_score`);
ALTER TABLE `fa_jj_agent_profile` ADD INDEX `idx_user_id` (`user_id`);
```

### 第 7 步：查询合并优化（代码层）

以下为高优先级可优化的查询，建议在正式上线前完成：

#### 7.1 FcOrder/index — 6 个 count 合并为 1 条 SQL

优化前（7 次查询）：
```php
$stats = [
    'pending'   => Order::where('factory_id', $fid)->where('status', 0)->count(),
    'deposit'   => Order::where('factory_id', $fid)->where('status', 2)->count(),
    'contract'  => Order::where('factory_id', $fid)->where('status', 3)->count(),
    'executing' => Order::where('factory_id', $fid)->where('status', 4)->count(),
    'settling'  => Order::where('factory_id', $fid)->where('status', 5)->count(),
    'settled'   => Order::where('factory_id', $fid)->where('status', 6)->count(),
];
```

优化后（1 次查询）：
```php
$statusCounts = Db::name('jj_order')
    ->where('factory_id', $fid)
    ->field('status, COUNT(*) as cnt')
    ->group('status')
    ->select();
$countMap = array_column($statusCounts, 'cnt', 'status');
$stats = [
    'pending'   => intval($countMap[0] ?? 0),
    'deposit'   => intval($countMap[2] ?? 0),
    'contract'  => intval($countMap[3] ?? 0),
    'executing' => intval($countMap[4] ?? 0),
    'settling'  => intval($countMap[5] ?? 0),
    'settled'   => intval($countMap[6] ?? 0),
];
```

#### 7.2 FcDashboard/overview — 7 次查询合并为 3 次

优化前：7 次独立 count/sum

优化后：
```php
// 查询1：月度+总计聚合（合并4个查询为1个）
$agg = Db::name('jj_order')->where('factory_id', $fid)
    ->where('status', '>=', Order::STATUS_DEPOSIT)
    ->field([
        'COUNT(*) as total_orders',
        'SUM(IF(createtime >= ' . $monthStart . ' AND createtime < ' . $monthEnd . ', 1, 0)) as month_orders',
        'SUM(IF(createtime >= ' . $monthStart . ' AND createtime < ' . $monthEnd . ', total_amount, 0)) as month_amount',
    ])->find();

// 查询2：待办聚合（合并3个count为1个）
$todoAgg = Db::name('jj_order')->where('factory_id', $fid)
    ->whereIn('status', [0, 2, 4])
    ->field('status, COUNT(*) as cnt')
    ->group('status')
    ->select();

// 查询3：平均响应时间（保持不变）
$avgResult = Db::name('jj_order')...;
```

#### 7.3 Dashboard 数据添加 Redis 缓存

```php
public function overview()
{
    $factory = $this->getFactory();
    $cacheKey = 'fc_overview_' . $factory['id'];

    // 缓存 60 秒
    $data = cache($cacheKey);
    if ($data) {
        $this->success('查询成功', $data);
        return;
    }

    // ... 原有查询逻辑 ...

    $data = [
        'month_orders'       => $monthOrders,
        'month_amount'       => $this->formatMoney($monthAmount),
        // ...
    ];

    cache($cacheKey, $data, 60);
    $this->success('查询成功', $data);
}
```

建议缓存的接口及缓存时长：

| 接口 | 缓存时长 | 理由 |
|------|---------|------|
| `fc_dashboard/overview` | 60 秒 | 统计数据无需实时 |
| `fc_dashboard/product_stats` | 120 秒 | TOP10 变化慢 |
| `fc_dashboard/finance_stats` | 60 秒 | 财务摘要无需实时 |
| `fc_agent/list` | 300 秒 | 居间人数据变化慢 |
| `fc_order/todo_count` | 30 秒 | 待办提示需较新 |
| `fc_product/index` | 不缓存 | 操作频繁需实时 |
| `fc_order/index` | 不缓存 | 操作频繁需实时 |

> 在订单状态变更（confirm/lock_commission/release_payment 等）时清除相关缓存：
> ```php
> cache('fc_overview_' . $fid, null);
> cache('fc_finance_' . $fid, null);
> ```

---

## 五、部署上线 Checklist

### 环境准备

- [ ] 服务器安装 Nginx、PHP 8.1-FPM、Redis
- [ ] 配置 Nginx 虚拟主机（参照第 2 步）
- [ ] 配置 PHP-FPM 进程池（参照第 3 步）
- [ ] Redis 启动并设置密码
- [ ] 项目代码上传至 `/var/www/xiluxc/`
- [ ] 设置目录权限：`runtime/` 和 `public/uploads/` 可写

### 应用配置

- [ ] `.env` 切换为正式环境配置（debug=false）
- [ ] 数据库连接改为 localhost（Unix Socket）
- [ ] 缓存驱动改为 Redis
- [ ] Session 驱动改为 Redis
- [ ] `composer install --no-dev`（不安装开发依赖）

### 数据库优化

- [ ] 执行第 6 步的索引创建 SQL
- [ ] 开启 MySQL 慢查询日志（`slow_query_log = 1`, `long_query_time = 1`）

### 代码优化

- [ ] FcOrder/index 状态 count 合并（第 7.1 步）
- [ ] FcDashboard/overview 查询合并（第 7.2 步）
- [ ] 高频接口添加 Redis 缓存（第 7.3 步）
- [ ] 订单操作方法中添加缓存清除逻辑

### 安全加固

- [ ] Nginx 禁止访问 application/runtime/vendor 目录
- [ ] `.env` 文件权限设为 600
- [ ] 关闭 PHP 错误显示（`display_errors = Off`）
- [ ] 开启 HTTPS（Let's Encrypt 免费证书）
- [ ] MySQL 禁止远程 root 登录

### 上线验证

- [ ] 访问首页正常
- [ ] API 接口响应正常（用测试账号验证）
- [ ] 静态资源加载正常
- [ ] Redis 缓存生效（`redis-cli keys 'xiluxc_*'`）
- [ ] PHP-FPM 慢日志无异常
- [ ] Nginx 错误日志无异常

---

## 六、优化前后预估对比

| 指标 | 当前（php -S 跨机） | 同机 Nginx+FPM | + Redis + 查询优化 |
|------|-------------------|----------------|-------------------|
| 单请求延迟 | 200-500ms | 30-80ms | 5-20ms（缓存命中） |
| Dashboard 页面 | ~15 次 DB 查询 | ~15 次（更快） | 0 次（缓存） / 5 次（未命中） |
| 订单列表页 | ~7 次 DB 查询 | ~7 次（更快） | ~2 次 |
| 并发用户数 | 1-3 人 | 50-100 人 | 200-500 人 |
| QPS | 5-10 | 100-300 | 500-1500 |

---

## 七、监控建议（上线后）

```bash
# PHP-FPM 状态监控（需在 FPM 配置中开启 pm.status_path）
curl http://localhost/fpm-status

# Redis 监控
redis-cli info stats | grep instantaneous_ops_per_sec

# MySQL 慢查询
tail -f /var/log/mysql/slow.log

# Nginx 并发连接数
ss -s | grep estab

# 系统负载
top -bn1 | head -5
```

---

*文档版本：v1.0*
*编写日期：2026-02-10*
*适用项目：蓝衫网工厂端 + 居间人端*
