# 工厂端全流程问题清单

> 检查日期：2026-02-15
> 检查范围：工厂接单 → 锁定佣金 → 审核合同 → 审核付款凭证 → 确认发货/放款 → 结算 全流程
> 同时涵盖：钱包充值 → 提现 → 资金流水 全链路

---

## 一、工厂端订单状态生命周期

```
居间人下单 → 0 待确认
    ↓ 工厂 confirm()
1 待缴保证金（等待居间人缴纳保证金）
    ↓ 居间人 pay_deposit()
2 已缴保证金（等待工厂锁定佣金）
    ↓ 工厂 lock_commission()
3 合同上传中（等待居间人上传合同）
    ↓ 居间人 submit_contract() → 工厂 review_contract(approve)
4 履约执行中（等待居间人上传付款凭证）
    ├── 工厂 review_payment(approve) → 5 待结算 → 工厂 release_payment() → 6 已结算
    ├── 工厂 confirm_shipment() → 6 已结算（跳过待结算，自动结算）
    └── 超时 → 工厂 fail_settle() → 8 已逾期（违约结算）
```

---

## 二、各环节 API 完整性

| 环节 | API 端点 | 状态 |
|------|----------|------|
| 订单列表 | `fc_order/index` | 正常 |
| 订单详情 | `fc_order/detail` | 正常 |
| 确认接单 | `fc_order/confirm` | 正常 |
| 锁定佣金 | `fc_order/lock_commission` | **有问题** |
| 审核合同 | `fc_order/review_contract` | **有问题** |
| 审核付款凭证 | `fc_order/review_payment` | 正常 |
| 确认发货（自动结算） | `fc_order/confirm_shipment` | **有问题** |
| 同意放款（手动结算） | `fc_order/release_payment` | **有问题** |
| 违约结算 | `fc_order/fail_settle` | **有问题** |
| 待办统计 | `fc_order/todo_count` | 正常 |
| 钱包余额 | `fc_wallet/balance` | 正常 |
| 资金流水 | `fc_wallet/fund_log` | 正常 |
| 创建充值 | `fc_wallet/create_recharge` | **有问题** |
| 充值回调 | `fc_wallet/notify` | **有问题** |
| 对公账户管理 | `fc_wallet/bank_account_*` | **有问题** |
| 申请提现 | `fc_wallet/create_withdraw` | **有问题** |
| 提现记录 | `fc_wallet/withdraw_log` | 正常 |
| 托管列表 | `fc_wallet/escrow_list` | 正常 |

---

## 三、问题列表

### 问题 1：充值回调 notify() 双层事务嵌套导致数据异常

- **严重程度**：严重（上线阻断）
- **涉及文件**：
  - `application/api/controller/xiluxc/FcWallet.php` — `notify()` 方法（第 208-227 行）
  - `application/common/model/jj/FactoryRechargeOrder.php` — `payNotify()` 方法（第 36-68 行）
- **现状**：
  - `notify()` 在第 215 行开启 `Db::startTrans()`，然后调用 `payNotify()`
  - `payNotify()` 内部在第 38 行也开启 `Db::startTrans()`，形成嵌套事务
  - 如果 `payNotify()` 内部异常导致 rollback（第 65 行），ThinkPHP 5 的事务计数器被重置为 0
  - 此时外层 `Db::commit()`（第 222 行）在已回滚的事务上执行，结果不可预期
  - 且 `payNotify()` 如果 rollback 后返回 false（不抛异常），外层不检查返回值，仍然执行 commit
- **风险**：用户微信扣款成功，但工厂账户未入账（充值数据丢失）
- **解决方案**：
  1. 移除 `notify()` 中的外层事务包装，让 `payNotify()` 独立管理事务
  2. 或者移除 `payNotify()` 中的内部事务，统一由外层管理

---

### 问题 2：充值回调未验证支付金额

- **严重程度**：严重（安全风险）
- **涉及文件**：
  - `application/api/controller/xiluxc/FcWallet.php` — `notify()` 方法（第 211-224 行）
  - `application/common/model/jj/FactoryRechargeOrder.php` — `payNotify()` 方法
- **现状**：
  - 回调只提取 `out_trade_no` 和 `transaction_id`，没有校验 `$message['total_fee']`
  - 没有验证微信实际支付金额是否与订单金额一致
  - 也没有校验 `$message['result_code']` 是否为 `SUCCESS`
- **风险**：攻击者可能构造低金额支付请求，系统按订单原始金额入账
- **解决方案**：
  ```php
  if ($message['result_code'] !== 'SUCCESS') {
      return $fail('支付失败');
  }
  // 验证金额（微信回调金额单位为分）
  $order = FactoryRechargeOrder::where('order_no', $orderNo)->find();
  if ($message['total_fee'] != intval(bcmul($order->amount, 100))) {
      return $fail('金额不一致');
  }
  ```

---

### 问题 3：充值回调 notify() 中 $this->platform 可能未定义

- **严重程度**：严重（上线阻断）
- **涉及文件**：`application/api/controller/xiluxc/FcWallet.php` — `notify()` 方法（第 210 行）
- **现状**：
  - `notify()` 在 `$noNeedLogin` 列表中（第 25 行），不需要用户登录
  - 但第 210 行 `new Payment($this->platform)` 依赖 `$this->platform` 属性
  - 微信支付回调是微信服务器发起的 POST 请求，不会携带前端的 platform 标识
  - `$this->platform` 可能为 null 或空字符串，导致 Payment 初始化失败
- **解决方案**：notify() 中硬编码 platform 或从充值订单记录中读取

---

### 问题 4：充值回调 payNotify() 工厂账户不存在时静默跳过

- **严重程度**：严重（资金丢失风险）
- **涉及文件**：`application/common/model/jj/FactoryRechargeOrder.php` — `payNotify()` 第 57-60 行
- **现状**：
  ```php
  $account = FactoryAccount::where('factory_id', $order->factory_id)->find();
  if ($account) {
      $account->recharge($order->amount, $order->id, '微信充值到账');
  }
  ```
  - 如果工厂账户不存在（被删除或尚未创建），充值订单被标记为 PAID，但**不执行任何入账操作**
  - 用户微信已扣款，但工厂余额为 0
- **解决方案**：改为 `FactoryAccount::getOrCreate()` 确保账户存在，或在 account 不存在时抛异常触发 rollback

---

### 问题 5：结算流程缺少行锁保护，存在并发双重支付风险

- **严重程度**：严重（资金安全）
- **涉及文件**：
  - `application/api/controller/xiluxc/FcOrder.php`
    - `confirm_shipment()` 第 552 行 — 查询 order 未加锁
    - `release_payment()` 第 731 行 — 查询 order 未加锁
    - `fail_settle()` 第 938 行 — 查询 order 未加锁
- **现状**：
  - 三个结算方法都先无锁查询 order → 检查 status → 开启事务 → 执行结算
  - 在「查询 + 状态校验」和「事务开启」之间存在时间窗口
  - 并发请求可能都通过状态校验，然后都执行结算逻辑，导致：
    - 佣金重复发放给居间人（`User::money()` 被调用多次）
    - 工厂冻结金额被多次扣减（`$account->settle()` 被调用多次）
    - 保证金被重复退还/赔付
  - Escrow 查询也未加锁（`confirm_shipment` 第 567 行、`release_payment` 第 751 行）
- **解决方案**：
  ```php
  Db::startTrans();
  try {
      // 事务内重新查询并加行锁
      $order = Order::lock(true)->where('id', $orderId)->where('factory_id', $factory['id'])->find();
      if ($order['status'] != Order::STATUS_EXECUTING) {
          Db::rollback();
          $this->error('当前订单状态不允许操作');
      }
      // ...结算逻辑
  ```

---

### 问题 6：confirm_shipment() 中 settle() 返回值未检查

- **严重程度**：中等（数据一致性）
- **涉及文件**：`application/api/controller/xiluxc/FcOrder.php` — `confirm_shipment()` 第 642-645 行
- **现状**：
  ```php
  $account = FactoryAccount::where('factory_id', $factory['id'])->find();
  if ($account) {
      $account->settle($totalFrozen, $orderId, '...');
  }
  ```
  - `settle()` 返回 bool，但不检查返回值
  - 如果 settle 失败（冻结余额不足），代码仍继续创建 Commission 记录、标记保证金退还、更改订单为已结算
  - 结果：订单显示已结算，但工厂冻结金额未实际扣除
  - `release_payment()` 第 770-773 行存在同样问题
- **解决方案**：检查 settle() 返回值，失败时回滚事务

---

### 问题 7：review_contract() 日志记录的 from_status 错误

- **严重程度**：低（数据记录不准确）
- **涉及文件**：`application/api/controller/xiluxc/FcOrder.php` — `review_contract()` 第 474-492 行
- **现状**：
  - 第 474 行 `$order->save(['status' => Order::STATUS_EXECUTING])` 修改了 order 对象的状态
  - 第 487 行 `'from_status' => $order['status']` 此时读取的是**已修改后**的状态 (STATUS_EXECUTING)
  - OrderLog 记录变为 `from_status = 4, to_status = 4`（EXECUTING → EXECUTING），实际应为 `3 → 4`（CONTRACT → EXECUTING）
- **解决方案**：在 save 之前先保存原始状态 `$originalStatus = $order['status']`

---

### 问题 8：lock_commission() 未检查重复托管

- **严重程度**：中等（资金安全）
- **涉及文件**：`application/api/controller/xiluxc/FcOrder.php` — `lock_commission()` 第 356-413 行
- **现状**：
  - 没有检查该订单是否已存在 Escrow 托管记录
  - 第 366 行直接 `Escrow::create()`，不检查是否已有 `status=HOLDING` 的记录
  - 如果因网络重试或并发请求调用两次，会创建两条 Escrow 记录，冻结工厂余额两次
  - 虽然订单状态检查（第 324 行）提供部分保护，但并发窗口下仍可能通过
- **解决方案**：
  1. 在事务内对 order 加行锁
  2. 创建 Escrow 前检查是否已存在 holding 状态的记录
  3. 给 `(order_id, factory_id, status)` 加唯一索引

---

### 问题 9：工厂提现缺少后台审批流程

- **严重程度**：中等（功能缺失）
- **涉及文件**：
  - `application/common/model/jj/FactoryWithdraw.php` — applyWithdraw() 创建提现记录（state=1 审核中）
  - 缺少：后台管理控制器处理审核/拒绝
- **现状**：
  - 工厂可以申请提现（`fc_wallet/create_withdraw`），提现记录状态为「审核中」
  - 但系统中**没有对应的后台管理页面**来审核/批准/拒绝工厂提现
  - 已有的 `admin/xiluxc/finance/ShopWithdraw.php` 只处理门店提现，不处理工厂提现
  - 提现记录会永远停留在「审核中」状态
- **解决方案**：创建 `admin/controller/xiluxc/finance/FactoryWithdraw.php` 后台控制器，参照 ShopWithdraw 实现审核/处理/拒绝功能

---

### 问题 10：FactoryWithdraw.refundOnRefuse() 可被重复调用

- **严重程度**：中等（资金安全）
- **涉及文件**：`application/common/model/jj/FactoryWithdraw.php` — `refundOnRefuse()` 第 134-162 行
- **现状**：
  - 拒绝提现后退回金额的方法只检查 `state == STATE_REFUSED`
  - 没有标记「退款已完成」，也没有改变提现记录状态
  - 如果该方法被调用两次，会重复退款给工厂
  - 另外该方法注释说「调用方需自行管理事务」，但方法内部没有事务保护
- **解决方案**：
  1. 添加退款标记字段（如 `refund_done`），退款后标记为已退
  2. 或者在方法内部加事务包装和幂等性检查

---

### 问题 11：FactoryBankAccount.setDefault() 无事务保护

- **严重程度**：低（数据一致性）
- **涉及文件**：`application/common/model/jj/FactoryBankAccount.php` — `setDefault()` 第 27-38 行
- **现状**：
  ```php
  // 取消当前默认
  self::where('factory_id', $factoryId)->where('is_default', 1)->update(['is_default' => 0]);
  // 设置新默认
  return self::where('id', $accountId)->where('factory_id', $factoryId)->update(['is_default' => 1]);
  ```
  - 两步操作没有事务包装
  - 如果第一步成功、第二步失败，所有账户的 `is_default` 都为 0（无默认账户）
- **解决方案**：包裹 `Db::startTrans()` / `Db::commit()`

---

### 问题 12：release_payment() 注释与代码不一致

- **严重程度**：低（不影响功能，但容易误导）
- **涉及文件**：`application/api/controller/xiluxc/FcOrder.php` — `release_payment()` 第 775 行
- **现状**：
  - 注释写 `居间人到手 = commission × 80%（扣20%个税，不扣平台费）`
  - 实际 `Escrow::TAX_RATE = 0`（`Escrow.php` 第 28 行），居间人拿到 100%
  - 与居间人端问题清单中的问题 3 相同，此处再次标记
- **说明**：税务方案尚未落地，上线前需与产品/财务确认

---

### 问题 13：Debug 模式下充值可绕过支付

- **严重程度**：低（仅影响测试环境，上线前需确认关闭）
- **涉及文件**：`application/api/controller/xiluxc/FcWallet.php` — `create_recharge()` 第 159-180 行
- **现状**：
  - `app_debug = true` 且 openid 为空时，直接模拟充值成功
  - `lock_commission()` debug 模式下接受任意分钟数作为合同上传期限
- **风险**：如果上线后 `app_debug` 未关闭，任何人都可以免费充值
- **解决方案**：上线前确保 `.env` 中 `app_debug = false`，或在代码中增加额外的 IP 白名单检查

---

## 四、前端页面完整性

pages.json 中注册的工厂端页面：

| 页面 | 用途 | 状态 |
|------|------|------|
| `fc_main` | 主入口页 | 已注册 |
| `fc_home` | 首页/工作台 | 已注册 |
| `fc_auth` | 企业认证 | 已注册 |
| `fc_products` | 商品管理列表 | 已注册 |
| `fc_product_edit` | 产品编辑 | 已注册 |
| `fc_orders` | 订单列表 | 已注册 |
| `fc_order_detail` | 订单详情（含接单/锁佣/审核合同/审核凭证/发货/放款） | 已注册 |
| `fc_bids` | 竞标管理 | 已注册 |
| `fc_bid_quote` | 报价提交 | 已注册 |
| `fc_agents` | 居间人筛选 | 已注册 |
| `fc_dashboard` | 数据看板 | 已注册 |
| `fc_points` | 积分中心 | 已注册 |
| `fc_profile` | 个人中心 | 已注册 |
| `fc_wallet` | 我的钱包 | 已注册 |
| `fc_recharge` | 充值页面 | 已注册 |

> 注：pages.json 注册较完整（15个页面），但需确认各页面源码是否齐全。目前已确认 fc_order_detail、fc_wallet、fc_recharge 有完整源码。

---

## 五、资金流总结

### 工厂充值流程

```
工厂 → fc_wallet/create_recharge → 微信支付 → notify回调
                                                    ↓
                              FactoryRechargeOrder::payNotify()
                                                    ↓
                              FactoryAccount::recharge() → 可用余额增加
```

**问题点**：回调双层事务嵌套、金额未校验、账户不存在静默跳过

### 正常结算路径（confirm_shipment 或 release_payment）

```
工厂冻结金额 (commission + service_fee)
    ↓ FactoryAccount::settle()
佣金 → User::money() → 100%打入居间人余额（个税暂不扣）
服务费 → 平台收入
保证金 → 标记 REFUNDED（实际退还待居间人端对接支付后处理）
```

**问题点**：settle()返回值未检查、无行锁保护、可能并发双重结算

### 违约结算路径（fail_settle）

```
保证金(100%) → FactoryAccount::recharge() → 赔付至工厂可用余额
平台费(保证金×50%) → FactoryAccount::settle() → 从冻结中扣除（平台收入）
工厂佣金(commission + 剩余service_fee) → FactoryAccount::unfreeze() → 解冻退回工厂
居间人 → 得到 0（损失全部保证金）
Escrow → 标记 REFUNDED
```

**问题点**：无行锁保护、可能并发双重执行

### 提现流程

```
工厂 → fc_wallet/create_withdraw
    ↓ FactoryWithdraw::applyWithdraw()
扣减可用余额 → 创建提现记录(state=1审核中)
    ↓ 【缺少后台审核环节】
state=3 已处理 / state=4 已拒绝
    ↓ 如果拒绝
FactoryWithdraw::refundOnRefuse() → 退回余额
```

**问题点**：无后台审批入口、退款可重复调用

---

## 六、优先级排序

| 优先级 | 问题 | 说明 |
|--------|------|------|
| P0 | 问题 1：notify() 双层事务嵌套 | 上线必须修复，否则充值数据可能丢失 |
| P0 | 问题 2：notify() 未验证支付金额 | 安全风险，可被利用低价充值 |
| P0 | 问题 3：notify() platform 未定义 | 上线后回调可能直接报错 |
| P0 | 问题 4：payNotify() 账户不存在静默跳过 | 资金丢失风险 |
| P0 | 问题 5：结算流程缺少行锁，并发双重支付 | 资金安全，佣金可能重复发放 |
| P1 | 问题 6：settle() 返回值未检查 | 数据一致性，订单状态与资金不匹配 |
| P1 | 问题 8：lock_commission() 重复托管 | 工厂资金可能被多次冻结 |
| P1 | 问题 9：工厂提现缺少后台审批 | 功能缺失，提现永远卡在审核中 |
| P1 | 问题 10：refundOnRefuse() 可重复退款 | 资金安全 |
| P2 | 问题 7：review_contract() 日志 from_status 错误 | 数据记录不准确 |
| P2 | 问题 11：setDefault() 无事务保护 | 低频操作，影响有限 |
| P2 | 问题 12：release_payment() 注释误导 | 上线前需确认税率 |
| P2 | 问题 13：Debug 模式充值绕过 | 上线前关闭 app_debug 即可 |

---

## 七、P0 / P1 修复记录

> 修复日期：2026-02-15
> 修复范围：全部 P0（5个）+ 全部 P1（4个），共 9 个问题
> 说明：本次修复不涉及微信支付正式接入，保持现有支付模式

---

### 修复 1：notify() 双层事务 + 金额校验 + platform（问题 1、2、3）

**文件**：`application/api/controller/xiluxc/FcWallet.php` — `notify()` 方法

**修改内容**：
1. 移除外层 `Db::startTrans()` / `Db::commit()`，由 `payNotify()` 独立管理事务
2. 将 `new Payment($this->platform)` 改为 `new Payment('wxmini')`，硬编码 platform
3. 新增 `result_code` 校验，不为 `SUCCESS` 时直接 `$fail()`
4. 新增 `total_fee` 金额一致性校验（微信回调单位为分，用 `bcmul($order->amount, '100', 0)` 换算比对）
5. 新增已支付幂等判断（`PAY_STATUS_PAID` 时直接 return true）
6. 检查 `payNotify()` 返回值，失败时 `$fail('入账处理失败')`

**修复前**：
```php
public function notify()
{
    $payment = new Payment($this->platform);
    $response = $payment->getPayment()->handlePaidNotify(function ($message, $fail) {
        $orderNo     = $message['out_trade_no'];
        $transactionId = $message['transaction_id'];
        Db::startTrans();
        try {
            FactoryRechargeOrder::payNotify($orderNo, $transactionId);
        } catch (\Exception $e) {
            Db::rollback();
            return $e->getMessage();
        }
        Db::commit();
        return true;
    });
    ...
}
```

**修复后**：
```php
public function notify()
{
    $platform = 'wxmini';
    $payment = new Payment($platform);
    $response = $payment->getPayment()->handlePaidNotify(function ($message, $fail) {
        if (!isset($message['result_code']) || $message['result_code'] !== 'SUCCESS') {
            return $fail('支付失败');
        }
        $orderNo       = $message['out_trade_no'] ?? '';
        $transactionId = $message['transaction_id'] ?? '';
        $totalFee      = intval($message['total_fee'] ?? 0);

        $order = FactoryRechargeOrder::where('order_no', $orderNo)->find();
        if (!$order) { return $fail('订单不存在'); }
        if ($order->pay_status == FactoryRechargeOrder::PAY_STATUS_PAID) {
            return true; // 幂等
        }
        $expectedFee = intval(bcmul($order->amount, '100', 0));
        if ($totalFee !== $expectedFee) { return $fail('支付金额不一致'); }

        $result = FactoryRechargeOrder::payNotify($orderNo, $transactionId);
        if (!$result) { return $fail('入账处理失败'); }
        return true;
    });
    ...
}
```

---

### 修复 2：payNotify() 账户不存在时静默跳过（问题 4）

**文件**：`application/common/model/jj/FactoryRechargeOrder.php` — `payNotify()` 方法

**修改内容**：
1. 将 `FactoryAccount::where('factory_id', ...)->find()` 改为 `FactoryAccount::getOrCreate()`，确保账户一定存在
2. 检查 `recharge()` 返回值，失败时 `throw new \Exception('充值入账失败')` 触发回滚

**修复前**：
```php
$account = FactoryAccount::where('factory_id', $order->factory_id)->find();
if ($account) {
    $account->recharge($order->amount, $order->id, '微信充值到账');
}
```

**修复后**：
```php
$account = FactoryAccount::getOrCreate($order->factory_id, $order->user_id);
$rechargeResult = $account->recharge($order->amount, $order->id, '微信充值到账');
if (!$rechargeResult) {
    throw new \Exception('充值入账失败');
}
```

---

### 修复 3：结算流程加行锁防并发（问题 5）

**文件**：`application/api/controller/xiluxc/FcOrder.php`

**修改方法**：`confirm_shipment()`、`release_payment()`、`fail_settle()` 共 3 个方法

**修改策略**：
- 保留事务外的初始查询作为「快速失败」校验（减少不必要的锁等待）
- 将核心校验逻辑（order 状态、付款凭证、托管记录）全部移入 `Db::startTrans()` 内部
- 事务内用 `Order::lock(true)` 加行锁重新校验订单状态
- Escrow 查询加 `->lock(true)` 防止并发修改
- 校验失败时先 `Db::rollback()` 再 `$this->error()`

**confirm_shipment() 修复后关键代码**：
```php
$order = Order::where(...)->find();  // 快速失败
if ($order['status'] != Order::STATUS_EXECUTING) { $this->error('...'); }

Db::startTrans();
try {
    $order = Order::lock(true)->where('id', $orderId)->find();
    if ($order['status'] != Order::STATUS_EXECUTING) {
        Db::rollback();
        $this->error('订单状态已变更，请刷新重试');
    }
    $proof = PaymentProof::where('order_id', $orderId)->find();
    // ... 校验 proof ...
    $escrow = Escrow::where(...)->lock(true)->find();
    // ... 结算逻辑 ...
}
```

**release_payment() 修复后关键代码**：
```php
Db::startTrans();
try {
    $order = Order::lock(true)->where('id', $orderId)->find();
    if ($order['status'] != Order::STATUS_SETTLING) {
        Db::rollback();
        $this->error('订单状态已变更，请刷新重试');
    }
    $paymentProof = PaymentProof::where(...)->find();
    // ... 校验 proof ...
    $escrow = Escrow::where(...)->lock(true)->find();
    // ... 结算逻辑 ...
}
```

**fail_settle() 修复后关键代码**：
```php
Db::startTrans();
try {
    $order = Order::lock(true)->where('id', $orderId)->find();
    // 超时条件验证（在锁内进行）...
    $deposit = Deposit::where(...)->find();
    $escrow = Escrow::where(...)->lock(true)->find();
    // ... 违约结算逻辑 ...
}
```

---

### 修复 4：settle() 返回值检查（问题 6）

**文件**：`application/api/controller/xiluxc/FcOrder.php`

**修改方法**：`confirm_shipment()`、`release_payment()` 共 2 处

**修改内容**：
1. account 查询加 `->lock(true)` 防止并发读取过期数据
2. 当 account 不存在时 `throw new \Exception('工厂账户不存在')`
3. 检查 `settle()` 返回值，失败时 `throw new \Exception('佣金结算扣款失败')`

**修复前（两处相同）**：
```php
$account = FactoryAccount::where('factory_id', $factory['id'])->find();
if ($account) {
    $account->settle($totalFrozen, $orderId, '...');
}
```

**修复后（两处相同）**：
```php
$account = FactoryAccount::where('factory_id', $factory['id'])->lock(true)->find();
if (!$account) {
    throw new \Exception('工厂账户不存在');
}
$settleResult = $account->settle($totalFrozen, $orderId, '...');
if (!$settleResult) {
    throw new \Exception('佣金结算扣款失败');
}
```

---

### 修复 5：lock_commission() 防重复托管（问题 8）

**文件**：`application/api/controller/xiluxc/FcOrder.php` — `lock_commission()` 方法

**修改内容**：在事务开始后、冻结操作前，新增两项检查：
1. `Order::lock(true)` 加锁重新校验订单状态
2. 查询是否已存在 `status=HOLDING` 的 Escrow 记录（加锁查询），存在则拒绝

**新增代码**：
```php
Db::startTrans();
try {
    // 事务内加锁重新校验（防并发重复冻结）
    $order = Order::lock(true)->where('id', $orderId)->find();
    if (!in_array($order['status'], [Order::STATUS_DEPOSIT, Order::STATUS_DEPOSITED])) {
        Db::rollback();
        $this->error('订单状态已变更，请刷新重试');
    }

    // 检查是否已存在托管记录（防重复冻结）
    $existingEscrow = Escrow::where('order_id', $orderId)
        ->where('factory_id', $factory['id'])
        ->where('status', Escrow::STATUS_HOLDING)
        ->lock(true)
        ->find();
    if ($existingEscrow) {
        Db::rollback();
        $this->error('佣金已锁定，请勿重复操作');
    }

    // 从钱包冻结佣金+服务费 ...
```

---

### 修复 6：工厂提现后台审批控制器（问题 9）

**新增文件**：`application/admin/controller/xiluxc/finance/FactoryWithdraw.php`

**功能**：
| 方法 | 功能 | 状态流转 |
|------|------|----------|
| `index()` | 提现列表（支持分页、筛选） | — |
| `processing()` | 审核通过 | 待审核(1) → 处理中(2) |
| `done()` | 确认已打款 | 处理中(2) → 已处理(3) |
| `refuse()` | 拒绝提现（必填原因，自动退回金额） | 待审核(1) → 已拒绝(4) + 退款 |

**安全措施**：
- 所有状态变更均在事务内加行锁 `->lock(true)` 执行
- 拒绝时自动调用 `FactoryWithdraw::refundOnRefuse()` 退回金额
- 禁用 `add()` 和 `del()` 方法

> 注：后台视图和菜单需通过 `php think menu:create` 或后台手动添加菜单后才能在管理面板显示。

---

### 修复 7：refundOnRefuse() 幂等保护（问题 10）

**文件**：`application/common/model/jj/FactoryWithdraw.php` — `refundOnRefuse()` 方法

**修改内容**：
1. 新增 `Db::startTrans()` 事务包装（原来无事务）
2. 新增幂等检查：查询 `FactoryFundLog` 中是否已存在该提现 ID 的 `TYPE_WITHDRAW_REFUND` 记录，存在则直接返回 true
3. 失败时 `Db::rollback()` + 重新抛出异常

**修复前**：
```php
public static function refundOnRefuse($withdrawId)
{
    $withdraw = self::lock(true)->find($withdrawId);
    if (!$withdraw || $withdraw->state != self::STATE_REFUSED) {
        throw new \Exception('提现记录状态异常');
    }
    // ... 直接退款，无幂等检查，无事务 ...
    return true;
}
```

**修复后**：
```php
public static function refundOnRefuse($withdrawId)
{
    Db::startTrans();
    try {
        $withdraw = self::lock(true)->find($withdrawId);
        if (!$withdraw || $withdraw->state != self::STATE_REFUSED) {
            throw new \Exception('提现记录状态异常');
        }
        // 幂等检查：是否已退款过
        $existingRefund = FactoryFundLog::where('order_id', $withdrawId)
            ->where('type', FactoryFundLog::TYPE_WITHDRAW_REFUND)
            ->find();
        if ($existingRefund) {
            Db::commit();
            return true; // 已退款，幂等返回
        }
        // ... 执行退款 ...
        Db::commit();
        return true;
    } catch (\Exception $e) {
        Db::rollback();
        throw $e;
    }
}
```

---

### 修复文件清单

| 文件 | 操作 | 涉及问题 |
|------|------|----------|
| `application/api/controller/xiluxc/FcWallet.php` | 修改 `notify()` | 问题 1、2、3 |
| `application/common/model/jj/FactoryRechargeOrder.php` | 修改 `payNotify()` | 问题 4 |
| `application/api/controller/xiluxc/FcOrder.php` | 修改 `confirm_shipment()`、`release_payment()`、`fail_settle()`、`lock_commission()` | 问题 5、6、8 |
| `application/common/model/jj/FactoryWithdraw.php` | 修改 `refundOnRefuse()` | 问题 10 |
| `application/admin/controller/xiluxc/finance/FactoryWithdraw.php` | **新增** | 问题 9 |

### 未修复的 P2 问题（不影响核心功能）

| 问题 | 说明 |
|------|------|
| 问题 7：review_contract() 日志 from_status 错误 | 数据记录不准确，不影响业务 |
| 问题 11：setDefault() 无事务保护 | 低频操作，影响有限 |
| 问题 12：release_payment() 注释误导 | 需产品/财务确认税率后调整 |
| 问题 13：Debug 模式充值绕过 | 上线前关闭 `app_debug` 即可 |
